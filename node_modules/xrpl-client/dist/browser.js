require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],2:[function(require,module,exports){
(function (global){(function (){
'use strict';

var objectAssign = require('object-assign');

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":11,"util/":5}],3:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],4:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],5:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":4,"_process":12,"inherits":3}],6:[function(require,module,exports){
(function (process){(function (){
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = require('./common')(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};

}).call(this)}).call(this,require('_process'))
},{"./common":7,"_process":12}],7:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;

},{"ms":10}],8:[function(require,module,exports){
var naiveFallback = function () {
	if (typeof self === "object" && self) return self;
	if (typeof window === "object" && window) return window;
	throw new Error("Unable to resolve global `this`");
};

module.exports = (function () {
	if (this) return this;

	// Unexpected strict mode (may happen if e.g. bundled into ESM module)

	// Fallback to standard globalThis if available
	if (typeof globalThis === "object" && globalThis) return globalThis;

	// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
	// In all ES5+ engines global object inherits from Object.prototype
	// (if you approached one that doesn't please report)
	try {
		Object.defineProperty(Object.prototype, "__global__", {
			get: function () { return this; },
			configurable: true
		});
	} catch (error) {
		// Unfortunate case of updates to Object.prototype being restricted
		// via preventExtensions, seal or freeze
		return naiveFallback();
	}
	try {
		// Safari case (window.__global__ works, but __global__ does not)
		if (!__global__) return naiveFallback();
		return __global__;
	} finally {
		delete Object.prototype.__global__;
	}
})();

},{}],9:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],10:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],11:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],12:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],13:[function(require,module,exports){
var _globalThis;
if (typeof globalThis === 'object') {
	_globalThis = globalThis;
} else {
	try {
		_globalThis = require('es5-ext/global');
	} catch (error) {
	} finally {
		if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
		if (!_globalThis) { throw new Error('Could not determine global this'); }
	}
}

var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
var websocket_version = require('./version');


/**
 * Expose a W3C WebSocket class with just one or two arguments.
 */
function W3CWebSocket(uri, protocols) {
	var native_instance;

	if (protocols) {
		native_instance = new NativeWebSocket(uri, protocols);
	}
	else {
		native_instance = new NativeWebSocket(uri);
	}

	/**
	 * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
	 * class). Since it is an Object it will be returned as it is when creating an
	 * instance of W3CWebSocket via 'new W3CWebSocket()'.
	 *
	 * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
	 */
	return native_instance;
}
if (NativeWebSocket) {
	['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
		Object.defineProperty(W3CWebSocket, prop, {
			get: function() { return NativeWebSocket[prop]; }
		});
	});
}

/**
 * Module exports.
 */
module.exports = {
    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
    'version'      : websocket_version
};

},{"./version":14,"es5-ext/global":8}],14:[function(require,module,exports){
module.exports = require('../package.json').version;

},{"../package.json":15}],15:[function(require,module,exports){
module.exports={
  "name": "websocket",
  "description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
  "keywords": [
    "websocket",
    "websockets",
    "socket",
    "networking",
    "comet",
    "push",
    "RFC-6455",
    "realtime",
    "server",
    "client"
  ],
  "author": "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
  "contributors": [
    "Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"
  ],
  "version": "1.0.34",
  "repository": {
    "type": "git",
    "url": "https://github.com/theturtle32/WebSocket-Node.git"
  },
  "homepage": "https://github.com/theturtle32/WebSocket-Node",
  "engines": {
    "node": ">=4.0.0"
  },
  "dependencies": {
    "bufferutil": "^4.0.1",
    "debug": "^2.2.0",
    "es5-ext": "^0.10.50",
    "typedarray-to-buffer": "^3.1.5",
    "utf-8-validate": "^5.0.2",
    "yaeti": "^0.0.6"
  },
  "devDependencies": {
    "buffer-equal": "^1.0.0",
    "gulp": "^4.0.2",
    "gulp-jshint": "^2.0.4",
    "jshint-stylish": "^2.2.1",
    "jshint": "^2.0.0",
    "tape": "^4.9.1"
  },
  "config": {
    "verbose": false
  },
  "scripts": {
    "test": "tape test/unit/*.js",
    "gulp": "gulp"
  },
  "main": "index",
  "directories": {
    "lib": "./lib"
  },
  "browser": "lib/browser.js",
  "license": "Apache-2.0"
}

},{}],16:[function(require,module,exports){
'use strict';

module.exports = function () {
  throw new Error(
    'ws does not work in the browser. Browser clients must use the native ' +
      'WebSocket object'
  );
};

},{}],"xrpl-client":[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrplClient = exports.defaultEndpoints = void 0;
const assert_1 = __importDefault(require("assert"));
const events_1 = require("events");
const debug_1 = require("debug");
const websocket_1 = require("websocket");
__exportStar(require("./types"), exports);
const log = (0, debug_1.debug)("xrplclient");
const logWarning = log.extend("warning");
const logMessage = log.extend("message");
const logNodeInfo = log.extend("node");
const connectAttemptTimeoutSeconds = 3;
const assumeOfflineAfterSeconds = 15;
const maxConnectionAttempts = null;
const feeCushion = 1.2;
const feeDropsDefault = 12;
const feeDropsMax = 3600;
const tryAllNodes = false;
exports.defaultEndpoints = [
    "wss://xrplcluster.com",
    "wss://xrpl.link",
    "wss://s2.ripple.com",
];
const endpointParser = (endpoint) => {
    let endpoints = [];
    if (endpoint) {
        endpoints = [
            ...new Set(Array.isArray(endpoint) ? endpoint : [endpoint]),
        ]
            .map((uplink) => uplink.trim())
            .filter((uplink) => uplink.match(/^ws[s]{0,1}:\/\//));
    }
    if (endpoints.length < 1) {
        endpoints = exports.defaultEndpoints;
        logWarning("No valid WebSocket endpoint(s) specified, falling back to defaults", endpoints);
    }
    return endpoints;
};
class XrplClient extends events_1.EventEmitter {
    constructor(endpoint, options) {
        var _a;
        super();
        this.eventBus = new events_1.EventEmitter();
        this.closed = false;
        this.destroyed = false;
        this.uplinkReady = false;
        this.options = {
            connectAttemptTimeoutSeconds,
            assumeOfflineAfterSeconds,
            maxConnectionAttempts,
            feeDropsDefault,
            feeDropsMax,
            tryAllNodes,
        };
        this.callId = 0;
        this.pendingCalls = [];
        this.subscriptions = [];
        this.networkDefinitions = null;
        this.serverState = {
            validatedLedgers: "",
            reserveBase: null,
            reserveInc: null,
            latency: [],
            fee: [],
            connectAttempts: -1,
            networkId: 0,
        };
        if (options) {
            Object.assign(this.options, options);
        }
        this.endpoints = endpointParser(endpoint);
        /**
         * Alive timer
         */
        let livelinessCheck;
        const alive = () => {
            var _a;
            // log('Start alive timer')
            clearTimeout(livelinessCheck);
            const seconds = Number(((_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.assumeOfflineAfterSeconds) || assumeOfflineAfterSeconds) * 1000;
            livelinessCheck = setTimeout(() => {
                var _a;
                // Only if the connection ever was online to begin with
                if (this.uplinkReady) {
                    logWarning(`Conn. TIMEOUT, no ledger for ${seconds} sec.`);
                    try {
                        log("Close #6");
                        (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
                    }
                    catch (e) { }
                }
            }, seconds);
        };
        alive();
        const reconnectTime = () => {
            var _a, _b;
            let factor = 1;
            const attempts = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts) || maxConnectionAttempts;
            if (attempts) {
                factor =
                    ((((_b = this.options) === null || _b === void 0 ? void 0 : _b.connectAttemptTimeoutSeconds) ||
                        connectAttemptTimeoutSeconds) -
                        1) /
                        (attempts - 1);
            }
            const reconnectSeconds = Math.max(1.5, (this.serverState.connectAttempts + 1) * factor);
            return reconnectSeconds;
        };
        this.endpoint = this.endpoints[0].trim();
        if (this.endpoints.length > 1 && !((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts)) {
            log(`Multiple endpoints (${this.endpoints.length}) and no maxConnection attempts, set (3)`);
            Object.assign(this.options, { maxConnectionAttempts: 3 });
        }
        log(`Initialized xrpld WebSocket Client`);
        this.on("ledger", () => {
            connectionReady();
            alive();
        });
        const ignore = () => { };
        /**
         * Important one
         */
        const connectionReady = () => {
            if (!this.uplinkReady) {
                this.serverState.connectAttempts = 0;
                logNodeInfo("Connection ready, fire events");
                this.uplinkReady = true;
                this.eventBus.emit("flush");
                this.emit("online");
                this.emit("state", this.getState());
            }
        };
        /**
         * WebSocket client event handlers
         */
        const WsOpen = () => {
            var _a, _b, _c;
            /**
             * We're firing two commands when we're connected
             */
            if (!this.closed && ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN) {
                log("Connection opened :)");
                /**
                 * XRPL Cluster state
                 */
                if (this.endpoint.match(/^wss:\/\/(xrplcluster\.com|xrpl\.link|xrpl\.ws)/)) {
                    try {
                        (_b = this === null || this === void 0 ? void 0 : this.connection) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({ __api: "state", origin: "xrpl-client@js/ts" }));
                    }
                    catch (e) { }
                }
                /**
                 * Mandatory messages on connect
                 */
                this.send({
                    id: "_WsClient_Internal_Subscription",
                    command: "subscribe",
                    streams: ["ledger"],
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(ignore, ignore);
                this.send({
                    id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                    command: "server_info",
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(() => {
                    connectionReady();
                }, ignore);
            }
            else {
                try {
                    log("Close #1");
                    (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.close();
                }
                catch (e) {
                    // If timing: came online after close: kill
                }
            }
        };
        const WsClose = (event) => {
            this.emit("close");
            this.emit("state", this.getState());
            if (this.uplinkReady) {
                // Was online
                this.emit("offline");
                // Was online, so start a new cycle instead of trying the next node
                this.endpoint = this.endpoints[0];
            }
            this.uplinkReady = false;
            this.serverInfo = undefined;
            logWarning("Upstream/Websocket closed", event === null || event === void 0 ? void 0 : event.code, event === null || event === void 0 ? void 0 : event.reason);
            WsCleanup();
            if (!this.closed) {
                this.emit("retry");
                logWarning(`Not closed on purpose, reconnecting after ${reconnectTime()}...`);
                setTimeout(() => {
                    this.eventBus.emit("reconnect");
                }, reconnectTime() * 1000);
            }
            else {
                log("Closed on purpose, not reconnecting");
            }
        };
        const handleServerInfo = (message, returnOnly = false) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            if ((_a = message === null || message === void 0 ? void 0 : message.result) === null || _a === void 0 ? void 0 : _a.info) {
                const serverState = returnOnly
                    ? Object.assign({}, this.serverState)
                    : this.serverState;
                const serverInfo = message;
                if (!this.serverInfo) {
                    if (!returnOnly) {
                        logNodeInfo("Connected, server_info:", {
                            pubkey_node: serverInfo.result.info.pubkey_node,
                            network_id: ((_b = serverInfo.result.info) === null || _b === void 0 ? void 0 : _b.network_id) || 0,
                            build_version: serverInfo.result.info.build_version,
                            complete_ledgers: serverInfo.result.info.complete_ledgers,
                        });
                    }
                }
                if ((_e = (_d = (_c = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.validated_ledger) === null || _e === void 0 ? void 0 : _e.reserve_base_xrp) {
                    serverState.reserveBase =
                        Number(serverInfo.result.info.validated_ledger.reserve_base_xrp) ||
                            null;
                }
                if ((_h = (_g = (_f = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.validated_ledger) === null || _h === void 0 ? void 0 : _h.reserve_inc_xrp) {
                    serverState.reserveInc =
                        Number(serverInfo.result.info.validated_ledger.reserve_inc_xrp) ||
                            null;
                }
                if ((_k = (_j = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.complete_ledgers) {
                    serverState.validatedLedgers =
                        serverInfo.result.info.complete_ledgers;
                }
                if ((_l = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _l === void 0 ? void 0 : _l.info) {
                    serverState.networkId = serverInfo.result.info.network_id || 0;
                }
                const msRoundTrip = Number(new Date()) -
                    Number(String((message === null || message === void 0 ? void 0 : message.id) || "")
                        .split("@")
                        .reverse()[0]);
                if (msRoundTrip) {
                    serverState.latency.push({
                        moment: new Date(),
                        value: msRoundTrip,
                    });
                    serverState.latency.splice(0, serverState.latency.length - 10);
                }
                const fee = Number(((_o = (_m = serverInfo.result.info) === null || _m === void 0 ? void 0 : _m.validated_ledger) === null || _o === void 0 ? void 0 : _o.base_fee_xrp) ||
                    (this.options.feeDropsDefault || feeDropsDefault) / 1000000) *
                    1000000 *
                    feeCushion;
                if (fee && fee <= (this.options.feeDropsMax || feeDropsMax)) {
                    serverState.fee.push({
                        moment: new Date(),
                        value: fee,
                    });
                    serverState.fee.splice(0, serverState.fee.length - 5);
                }
                if (!returnOnly) {
                    this.serverInfo = serverInfo;
                }
                else {
                    return { serverInfo, serverState };
                }
            }
        };
        const handleAsyncWsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._Request) !== "_WsClient_Internal_Subscription") {
                let matchingSubscription;
                if ((_b = message === null || message === void 0 ? void 0 : message.id) === null || _b === void 0 ? void 0 : _b._WsClient) {
                    const _matching = this.subscriptions.filter((s) => { var _a; return s.id === ((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._WsClient); });
                    if (_matching.length > 0) {
                        matchingSubscription = _matching[0];
                        matchingSubscription.promiseCallables.resolve(Object.assign(message, {
                            id: (_c = message === null || message === void 0 ? void 0 : message.id) === null || _c === void 0 ? void 0 : _c._Request,
                        }));
                    }
                }
                this.emit("message", message);
                if ((message === null || message === void 0 ? void 0 : message.type) === "ledgerClosed" &&
                    typeof (message === null || message === void 0 ? void 0 : message.validated_ledgers) === "string") {
                    logMessage("Async", message.type);
                    Object.assign(this.serverState, {
                        validatedLedgers: message.validated_ledgers,
                        reserveBase: Number(message === null || message === void 0 ? void 0 : message.reserve_base) / 1000000 || null,
                        reserveInc: Number(message === null || message === void 0 ? void 0 : message.reserve_inc) / 1000000 || null,
                    });
                    this.emit("ledger", message);
                    /**
                     * Always request a server_info for a received ledger as well
                     */
                    this.send({
                        id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                        command: "server_info",
                    }).then(ignore, ignore);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "path_find") {
                    logMessage("Async", message.type);
                    this.emit("path", message);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "transaction") {
                    logMessage("Async", message.type);
                    this.emit("transaction", message);
                }
                else if (message === null || message === void 0 ? void 0 : message.validation_public_key) {
                    logMessage("Async", "validation");
                    this.emit("validation", message);
                }
                else {
                    if (((_d = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _d === void 0 ? void 0 : _d.command) === "path_find") {
                        logMessage("Async", (_e = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _e === void 0 ? void 0 : _e.command);
                        this.emit("path", message);
                    }
                    else if (((_f = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _f === void 0 ? void 0 : _f.command) === "subscribe" &&
                        Array.isArray((_g = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _g === void 0 ? void 0 : _g.streams) &&
                        ((_h = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _h === void 0 ? void 0 : _h.streams.indexOf("ledger")) > -1) {
                        logMessage("Async", "subscription:ledger");
                        this.emit("ledger", (message === null || message === void 0 ? void 0 : message.result) ? message.result : message);
                    }
                    else if (matchingSubscription) {
                        // Don't log `Unknown` as we know this
                    }
                    else {
                        const isInternal = ((_j = message === null || message === void 0 ? void 0 : message.id) === null || _j === void 0 ? void 0 : _j._Request) &&
                            String(message.id._Request).match(/^_WsClient_Internal/);
                        if (!isInternal) {
                            try {
                                const clusterInfo = message;
                                if ((clusterInfo === null || clusterInfo === void 0 ? void 0 : clusterInfo.type) === "PROXY") {
                                    this.clusterInfo_ = clusterInfo;
                                    this.emit("clusterinfo", this.clusterInfo_);
                                    return;
                                }
                            }
                            catch (e) { }
                            logMessage(`Handle <UNKNOWN> Async Message`, {
                                internalId: (_k = message === null || message === void 0 ? void 0 : message.id) === null || _k === void 0 ? void 0 : _k._WsClient,
                                matchingSubscription,
                                type: message === null || message === void 0 ? void 0 : message.type,
                                message,
                            });
                        }
                    }
                }
            }
        };
        const WsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f;
            try {
                (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                const messageJson = JSON.parse(message.data);
                this.lastContact = new Date();
                if ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient) {
                    // Got response on a command, process accordingly
                    const matchingSubscription = this.subscriptions.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    const matchingCall = this.pendingCalls.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    if (matchingSubscription.length === 1) {
                        handleAsyncWsMessage(messageJson);
                    }
                    else if (matchingCall.length === 1) {
                        const internalServerInfoCall = String(((_d = (_c = (_b = matchingCall[0]) === null || _b === void 0 ? void 0 : _b.request) === null || _c === void 0 ? void 0 : _c.id) === null || _d === void 0 ? void 0 : _d._Request) || "").split("@")[0] === "_WsClient_Internal_ServerInfo";
                        Object.assign(messageJson, {
                            id: (_e = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _e === void 0 ? void 0 : _e._Request,
                        });
                        if (((_f = matchingCall[0].sendOptions) === null || _f === void 0 ? void 0 : _f.timeoutSeconds) &&
                            matchingCall[0].timeout) {
                            clearTimeout(matchingCall[0].timeout);
                        }
                        matchingCall[0].promiseCallables.resolve((messageJson === null || messageJson === void 0 ? void 0 : messageJson.result) || messageJson);
                        this.pendingCalls.splice(this.pendingCalls.indexOf(matchingCall[0]), 1);
                        if (!internalServerInfoCall) {
                            log(" Pending Call Length", this.pendingCalls.length);
                        }
                        else {
                            handleServerInfo(messageJson);
                        }
                    }
                    else {
                        // Subscription/path finding ack
                        handleAsyncWsMessage(messageJson);
                    }
                }
                else {
                    // Subscription/path finding followup
                    handleAsyncWsMessage(messageJson);
                }
            }
            catch (e) {
                logWarning("Uplink response: parse error", e.message);
            }
        };
        const WsError = (error) => {
            logWarning("Upstream/Websocket error");
        };
        const applyCallTimeout = (call) => {
            var _a;
            if (((_a = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _a === void 0 ? void 0 : _a.timeoutSeconds) && !(call === null || call === void 0 ? void 0 : call.timeout)) {
                Object.assign(call, {
                    timeout: setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const didTimeout = (yield Promise.race([
                            call.promise,
                            Promise.resolve("_WsClient_Internal_CallResolved"),
                        ])) === "_WsClient_Internal_CallResolved";
                        if (didTimeout) {
                            call.promiseCallables.reject(new Error(`Call timeout after ${(_b = call.sendOptions) === null || _b === void 0 ? void 0 : _b.timeoutSeconds} seconds`));
                        }
                    }), Number(call.sendOptions.timeoutSeconds) * 1000),
                });
            }
        };
        const process = (call) => {
            var _a, _b, _c, _d;
            // const isSubscription = call.request.command === "subscribe";
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log("  > Process call", call.id, call.request.command);
            }
            try {
                // log(call.request);
                (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.send(JSON.stringify(call.request));
                if ((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline) {
                    // logWarning("APPLY TIMEOUT ONLY AFTER GOING ONLINE");
                    applyCallTimeout(call);
                }
            }
            catch (e) {
                logWarning("Process (send to uplink) error", e.message);
            }
        };
        const call = (call) => {
            var _a, _b, _c, _d, _e;
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log(`Call ${call.id}: ${call.request.command}\n   > `, this.uplinkReady
                    ? "Uplink ready, pass immediately"
                    : ((_c = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _c === void 0 ? void 0 : _c.sendIfNotReady)
                        ? "Uplink not flagged as ready yet, but `sendIfNotReady` = true, so go ahead"
                        : "Uplink not ready, wait for flush");
            }
            if (!((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline)) {
                // logWarning("APPLY TIMEOUT NO MATTER ONLINE/OFFLINE STATE");
                applyCallTimeout(call);
            }
            if (this.uplinkReady || ((_e = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _e === void 0 ? void 0 : _e.sendIfNotReady)) {
                process(call);
            }
        };
        const flush = () => {
            /**
             * Flush all pending calls & subscriptions
             * to new uplink.
             */
            log("Connected, flushing pending calls & subscriptions");
            this.pendingCalls.forEach((call) => {
                process(call);
            });
            this.subscriptions.forEach((call) => {
                process(call);
            });
        };
        const reinstate = (options) => {
            (0, assert_1.default)(!this.destroyed, "Object is in destroyed state");
            log("Reinstating..., options:", options || {});
            if (options === null || options === void 0 ? void 0 : options.forceNextUplink) {
                this.uplinkReady = false; // Prevents going back to endpoint[0]
                clearTimeout(livelinessCheck);
                selectNextUplink();
            }
            else {
                this.closed = false;
                alive();
            }
            connect();
        };
        const close = (error) => {
            var _a;
            log("Closing connection");
            this.emit("close");
            this.closed = true;
            try {
                log("Close #2");
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            clearTimeout(livelinessCheck);
            if (error) {
                this.emit("error", error);
            }
        };
        const destroy = (error) => {
            this.destroyed = true;
            close(error);
            WsCleanup();
            this.subscriptions.forEach((subscription) => {
                subscription.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.pendingCalls.forEach((call) => {
                call.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.eventBus.off("__WsClient_call", call);
            this.eventBus.off("__WsClient_destroy", destroy);
            this.eventBus.off("__WsClient_close", close);
            this.eventBus.off("__WsClient_reinstate", reinstate);
            this.eventBus.off("flush", flush);
            this.eventBus.off("reconnect", connect);
        };
        const WsCleanup = () => {
            log("Cleanup");
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("open", WsOpen);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("message", WsMessage);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("error", WsError);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("close", WsClose);
        };
        const selectNextUplink = () => {
            const nextEndpointIndex = this.endpoints.indexOf(this.endpoint) + 1;
            logWarning("--- Current endpoint", this.endpoint);
            this.endpoint =
                this.endpoints[nextEndpointIndex >= this.endpoints.length ? 0 : nextEndpointIndex];
            logWarning("--- New endpoint", this.endpoint);
            this.serverState.connectAttempts = 0;
            this.emit("nodeswitch", this.endpoint);
            if (nextEndpointIndex >= this.endpoints.length) {
                this.emit("round");
            }
        };
        const connect = () => {
            var _a, _b, _c, _d;
            try {
                log("Close #3");
                WsCleanup();
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            log("connect()", this.endpoint);
            this.serverState.connectAttempts++;
            if (this.options.maxConnectionAttempts &&
                Number(((_b = this.options) === null || _b === void 0 ? void 0 : _b.maxConnectionAttempts) || 1) > 1 &&
                this.serverState.connectAttempts >=
                    Number(((_c = this.options) === null || _c === void 0 ? void 0 : _c.maxConnectionAttempts) || 1)) {
                logNodeInfo("Too many connection attempts", this.serverState.connectAttempts, (_d = this.options) === null || _d === void 0 ? void 0 : _d.maxConnectionAttempts);
                log(this.endpoint, this.endpoints, this.endpoints.length, this.endpoints.indexOf(this.endpoint));
                if (this.endpoints.length > 1 &&
                    this.endpoints.indexOf(this.endpoint) > -1) {
                    logWarning("Multiple endpoints, max. connection attempts exceeded. Switch endpoint.");
                    selectNextUplink();
                }
                else {
                    logWarning("Only one valid endpoint, after the max. connection attempts: game over");
                    close(new Error("Max. connection attempts exceeded"));
                }
            }
            if (!this.closed) {
                if (this.options.tryAllNodes) {
                    logWarning("!!!".repeat(30) +
                        "\n!!!\n!!!    Trying all nodes. WARNING! IF YOU DO NOT EXPLICITLY NEED THIS,\n!!!    DO NOT USE THE `tryAllNodes` OPTION (to prevent wasting resources)\n!!!\n" +
                        "!!!".repeat(30) +
                        "\n");
                }
                const allEndpoints = (this.options.tryAllNodes ? this.endpoints : [this.endpoint]).map((endpoint) => {
                    var _a, _b;
                    log("Connecting", endpoint);
                    /**
                     * Alternative WebSocket implementation here for Bun:
                     * Postprocessed in npm build cli
                     */
                    let WssClient = typeof WebSocket !== 'undefined' ? WebSocket : websocket_1.w3cwebsocket
                    if (typeof require !== 'undefined') {
                      try {
                        WssClient = require('ws').default
                      } catch (e) {}
                    }
                    const connection = new (typeof WssClient !== typeof _NA_ ? WssClient : websocket_1.w3cwebsocket)(endpoint, // url
                    undefined, // protocols
                    undefined, // origin
                    Object.assign(((_a = this.options) === null || _a === void 0 ? void 0 : _a.httpHeaders) || {}, {
                        "user-agent": "xrpl-client@js/ts",
                    }), // headers
                    ((_b = this.options) === null || _b === void 0 ? void 0 : _b.httpRequestOptions) || {}, // requestOptions
                    {
                        maxReceivedFrameSize: 0x80000000,
                        maxReceivedMessageSize: 0x200000000, // 8GB
                    } // IClientConfig
                    );
                    // Prevent possible DNS resolve hang, and a custom
                    // resolver sucks
                    setTimeout(() => {
                        var _a;
                        if (connection.readyState !== websocket_1.w3cwebsocket.OPEN &&
                            ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.readyState) !== websocket_1.w3cwebsocket.OPEN) {
                            log("Close #4 -- FORCED, inner connection timeout");
                            connection.close();
                            if (this.options.tryAllNodes) {
                                /**
                                 * Just do this once per X interval, instead of per connection.
                                 * We don't want all simultaneous connections to fire this and
                                 * kick off a fork (connection) bomb, so assuming they all
                                 * got tried if we're here, only fire reconnet for the very first
                                 * endpoint (as it'll make them all reconnect).
                                 */
                                if (this.endpoints.indexOf(endpoint) === 0) {
                                    this.eventBus.emit("reconnect");
                                }
                            }
                            else {
                                this.eventBus.emit("reconnect");
                            }
                        }
                    }, reconnectTime() * 1000 - 1);
                    const raceOpenHandler = () => {
                        log("OPEN", endpoint);
                        connection.send(JSON.stringify({ command: "server_info" }));
                    };
                    const raceMessageHandler = (message) => {
                        var _a;
                        (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                        const messageJson = JSON.parse(message.data);
                        const handledServerInfo = handleServerInfo(messageJson, true);
                        if (handledServerInfo) {
                            const serverState = this.getState(handledServerInfo.serverState);
                            if (typeof serverState.ledger.last === "number" &&
                                (Number(serverState.ledger.count || 0) || 0) > 0) {
                                // This one is first & sane
                                logNodeInfo("Race won by endpoint:", {
                                    endpoint,
                                    build_version: handledServerInfo.serverInfo.result.info.build_version,
                                    complete_ledgers: handledServerInfo.serverInfo.result.info.complete_ledgers,
                                    pubkey_node: handledServerInfo.serverInfo.result.info.pubkey_node,
                                    network_id: ((_a = handledServerInfo.serverInfo.result.info) === null || _a === void 0 ? void 0 : _a.network_id) || 0,
                                });
                                // this.options.tryAllNodes = false;
                                this.connection = connection;
                                this.endpoint = endpoint;
                                WsOpen();
                                WsMessage(message);
                                allEndpoints.forEach((iConnection) => {
                                    iConnection.removeEventListener("open", raceOpenHandler);
                                    iConnection.removeEventListener("message", raceMessageHandler);
                                    if (iConnection != connection) {
                                        log("Close #5");
                                        iConnection.close();
                                        logNodeInfo("Cleanup: closing connection & clearing event listeners for lost race connection", iConnection.url);
                                    }
                                    else {
                                        logNodeInfo("Cleanup: cleared event listeners for winning node", iConnection.url);
                                    }
                                });
                                connection.addEventListener("open", WsOpen);
                                connection.addEventListener("message", WsMessage);
                                connection.addEventListener("error", WsError);
                                connection.addEventListener("close", WsClose);
                            }
                        }
                    };
                    connection.addEventListener("open", raceOpenHandler);
                    connection.addEventListener("message", raceMessageHandler);
                    return connection;
                });
            }
            return this === null || this === void 0 ? void 0 : this.connection;
        };
        this.eventBus.on("__WsClient_call", call);
        this.eventBus.on("__WsClient_destroy", destroy);
        this.eventBus.on("__WsClient_close", close);
        this.eventBus.on("__WsClient_reinstate", reinstate);
        this.eventBus.on("flush", flush);
        this.eventBus.on("reconnect", connect);
        connect();
    }
    ready() {
        return new Promise((resolve, reject) => {
            const state = this.getState();
            if (state.online &&
                state.secLastContact &&
                state.secLastContact < 10 &&
                state.ledger.last) {
                // We're good
                return resolve(this);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("ledger", () => {
                    resolve(this);
                });
            }
        });
    }
    definitions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // null if not checked before
            if (this.networkDefinitions === null) {
                yield this.ready();
                const definitions = yield this.send({ command: "server_definitions" });
                if (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.FIELDS) === "object") {
                    this.networkDefinitions = definitions;
                    return this.networkDefinitions;
                }
                // Error, no definitions command, fallback to defaults
                if ((typeof (definitions === null || definitions === void 0 ? void 0 : definitions.status) === "string" &&
                    definitions.status.match(/error/i)) ||
                    (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.error) === "string" &&
                        definitions.error.match(/unknown/i))) {
                    this.networkDefinitions = {};
                }
            }
            // return null if {} (empty object) to fall back to defaults;
            // null internally (property) means unfetched, null externally
            // means fall back to defaults.
            return typeof ((_a = this.networkDefinitions) === null || _a === void 0 ? void 0 : _a.FIELDS) === "object"
                ? this.networkDefinitions
                : null;
        });
    }
    send(call, sendOptions = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const _call = Object.assign({}, call);
            (0, assert_1.default)(typeof _call === "object" && _call, "`send()`: expecting object containing `command`");
            (0, assert_1.default)(typeof _call.command === "string", "`command` must be typeof string");
            this.callId++;
            const promiseCallables = {
                resolve: (arg) => { },
                reject: (arg) => { },
            };
            const promise = new Promise((resolve, reject) => {
                Object.assign(promiseCallables, {
                    resolve: (arg) => {
                        Object.defineProperty(arg, 'id', {
                            enumerable: false,
                            writable: false,
                            value: call === null || call === void 0 ? void 0 : call.id,
                        });
                        return resolve(arg);
                    },
                    reject,
                });
            });
            const pendingCall = {
                id: this.callId,
                request: Object.assign(_call, {
                    id: {
                        _WsClient: this.callId,
                        _Request: _call === null || _call === void 0 ? void 0 : _call.id,
                    },
                    command: _call.command.toLowerCase().trim(),
                }),
                promise,
                promiseCallables,
                sendOptions,
            };
            if (this.destroyed) {
                promiseCallables.reject(new Error("Client in destroyed state"));
                return promise;
            }
            const isSubscription = (pendingCall.request.command === "subscribe" ||
                pendingCall.request.command === "unsubscribe" ||
                pendingCall.request.command === "path_find") &&
                !(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.noReplayAfterReconnect);
            if (((_a = pendingCall.request) === null || _a === void 0 ? void 0 : _a.command) === "unsubscribe" &&
                Array.isArray((_b = pendingCall.request) === null || _b === void 0 ? void 0 : _b.streams) &&
                ((_c = pendingCall.request) === null || _c === void 0 ? void 0 : _c.streams.indexOf("ledger")) > -1) {
                pendingCall.request.streams.splice(pendingCall.request.streams.indexOf("ledger"), 1);
                if (pendingCall.request.streams.length === 0 &&
                    Object.keys(pendingCall.request).filter((key) => key !== "id" && key !== "streams" && key !== "command").length === 0) {
                    // Unsubscribing (just) streams
                    return Promise.reject(new Error("Unsubscribing from (just) the ledger stream is not allowed"));
                }
            }
            if (String((_call === null || _call === void 0 ? void 0 : _call.id) || "").split("@")[0] !== "_WsClient_Internal_ServerInfo") {
                this[isSubscription ? "subscriptions" : "pendingCalls"].push(pendingCall);
            }
            this.eventBus.emit("__WsClient_call", pendingCall);
            return promise;
        });
    }
    getState(forcedServerState) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const serverState = forcedServerState
            ? forcedServerState
            : this.serverState;
        const ledgerCount = serverState.validatedLedgers
            .split(",")
            .map((m) => {
            const Range = m.split("-");
            return Range.length > 1 ? parseInt(Range[1]) - parseInt(Range[0]) : 1;
        })
            .reduce((a, b) => a + b, 0);
        return {
            online: this.uplinkReady &&
                !this.closed &&
                ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN,
            latencyMs: {
                last: serverState.latency
                    .slice(-1)
                    .map((latencyRecord) => latencyRecord.value)[0] || null,
                avg: serverState.latency
                    .map((latencyRecord) => latencyRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.latency.length || null,
                secAgo: Number(new Date()) / 1000 -
                    serverState.latency
                        .slice(-1)
                        .map((latencyRecord) => Number(latencyRecord.moment) / 1000)[0] ||
                    null,
            },
            server: {
                version: ((_d = (_c = (_b = this.serverInfo) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.build_version) || "",
                uptime: ((_g = (_f = (_e = this.serverInfo) === null || _e === void 0 ? void 0 : _e.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.uptime) || 0,
                publicKey: ((_k = (_j = (_h = this.serverInfo) === null || _h === void 0 ? void 0 : _h.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.pubkey_node) || "",
                networkId: ((_o = (_m = (_l = this.serverInfo) === null || _l === void 0 ? void 0 : _l.result) === null || _m === void 0 ? void 0 : _m.info) === null || _o === void 0 ? void 0 : _o.network_id) || 0,
                uri: this.endpoint,
            },
            ledger: {
                last: Number(serverState.validatedLedgers
                    .split(",")
                    .reverse()[0]
                    .split("-")
                    .reverse()[0]),
                validated: serverState.validatedLedgers,
                count: serverState.validatedLedgers === "" ? 0 : ledgerCount,
            },
            fee: {
                last: serverState.fee.slice(-1).map((feeRecord) => feeRecord.value)[0] ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                avg: serverState.fee
                    .map((feeRecord) => feeRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.fee.length ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                secAgo: Number(new Date()) / 1000 -
                    serverState.fee
                        .slice(-1)
                        .map((feeRecord) => Number(feeRecord.moment) / 1000)[0] || null,
            },
            reserve: {
                base: serverState.reserveBase,
                owner: serverState.reserveInc,
            },
            secLastContact: this.lastContact
                ? Number(new Date()) / 1000 - Number(this.lastContact) / 1000
                : null,
        };
    }
    close() {
        // assert(!this.closed, "Object already in closed state");
        log(`> CLOSE`);
        this.eventBus.emit("__WsClient_close");
    }
    reinstate(options) {
        // assert(!this.closed, "Object already reinstated state");
        log(`> REINSTATE`);
        this.eventBus.emit("__WsClient_reinstate", options);
    }
    destroy() {
        // assert(!this.closed, "Object already in destroyed state");
        log(`> DESTROY`);
        this.eventBus.emit("__WsClient_destroy");
    }
    clusterInfo() {
        return new Promise((resolve, reject) => {
            if (this.clusterInfo_) {
                // We're good
                return resolve(this.clusterInfo_);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("clusterinfo", (info) => {
                    resolve(info);
                });
            }
        });
    }
}
exports.XrplClient = XrplClient;

},{"./types":1,"assert":2,"debug":6,"events":9,"websocket":13,"ws":16}]},{},[]);
