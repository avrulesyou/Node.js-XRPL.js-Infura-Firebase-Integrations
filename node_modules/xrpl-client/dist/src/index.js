"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XrplClient = exports.defaultEndpoints = void 0;
const assert_1 = __importDefault(require("assert"));
const events_1 = require("events");
const debug_1 = require("debug");
const websocket_1 = require("websocket");
__exportStar(require("./types"), exports);
const log = (0, debug_1.debug)("xrplclient");
const logWarning = log.extend("warning");
const logMessage = log.extend("message");
const logNodeInfo = log.extend("node");
const connectAttemptTimeoutSeconds = 3;
const assumeOfflineAfterSeconds = 15;
const maxConnectionAttempts = null;
const feeCushion = 1.2;
const feeDropsDefault = 12;
const feeDropsMax = 3600;
const tryAllNodes = false;
exports.defaultEndpoints = [
    "wss://xrplcluster.com",
    "wss://xrpl.link",
    "wss://s2.ripple.com",
];
const endpointParser = (endpoint) => {
    let endpoints = [];
    if (endpoint) {
        endpoints = [
            ...new Set(Array.isArray(endpoint) ? endpoint : [endpoint]),
        ]
            .map((uplink) => uplink.trim())
            .filter((uplink) => uplink.match(/^ws[s]{0,1}:\/\//));
    }
    if (endpoints.length < 1) {
        endpoints = exports.defaultEndpoints;
        logWarning("No valid WebSocket endpoint(s) specified, falling back to defaults", endpoints);
    }
    return endpoints;
};
class XrplClient extends events_1.EventEmitter {
    constructor(endpoint, options) {
        var _a;
        super();
        this.eventBus = new events_1.EventEmitter();
        this.closed = false;
        this.destroyed = false;
        this.uplinkReady = false;
        this.options = {
            connectAttemptTimeoutSeconds,
            assumeOfflineAfterSeconds,
            maxConnectionAttempts,
            feeDropsDefault,
            feeDropsMax,
            tryAllNodes,
        };
        this.callId = 0;
        this.pendingCalls = [];
        this.subscriptions = [];
        this.networkDefinitions = null;
        this.serverState = {
            validatedLedgers: "",
            reserveBase: null,
            reserveInc: null,
            latency: [],
            fee: [],
            connectAttempts: -1,
            networkId: 0,
        };
        if (options) {
            Object.assign(this.options, options);
        }
        this.endpoints = endpointParser(endpoint);
        /**
         * Alive timer
         */
        let livelinessCheck;
        const alive = () => {
            var _a;
            // log('Start alive timer')
            clearTimeout(livelinessCheck);
            const seconds = Number(((_a = this === null || this === void 0 ? void 0 : this.options) === null || _a === void 0 ? void 0 : _a.assumeOfflineAfterSeconds) || assumeOfflineAfterSeconds) * 1000;
            livelinessCheck = setTimeout(() => {
                var _a;
                // Only if the connection ever was online to begin with
                if (this.uplinkReady) {
                    logWarning(`Conn. TIMEOUT, no ledger for ${seconds} sec.`);
                    try {
                        log("Close #6");
                        (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
                    }
                    catch (e) { }
                }
            }, seconds);
        };
        alive();
        const reconnectTime = () => {
            var _a, _b;
            let factor = 1;
            const attempts = ((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts) || maxConnectionAttempts;
            if (attempts) {
                factor =
                    ((((_b = this.options) === null || _b === void 0 ? void 0 : _b.connectAttemptTimeoutSeconds) ||
                        connectAttemptTimeoutSeconds) -
                        1) /
                        (attempts - 1);
            }
            const reconnectSeconds = Math.max(1.5, (this.serverState.connectAttempts + 1) * factor);
            return reconnectSeconds;
        };
        this.endpoint = this.endpoints[0].trim();
        if (this.endpoints.length > 1 && !((_a = this.options) === null || _a === void 0 ? void 0 : _a.maxConnectionAttempts)) {
            log(`Multiple endpoints (${this.endpoints.length}) and no maxConnection attempts, set (3)`);
            Object.assign(this.options, { maxConnectionAttempts: 3 });
        }
        log(`Initialized xrpld WebSocket Client`);
        this.on("ledger", () => {
            connectionReady();
            alive();
        });
        const ignore = () => { };
        /**
         * Important one
         */
        const connectionReady = () => {
            if (!this.uplinkReady) {
                this.serverState.connectAttempts = 0;
                logNodeInfo("Connection ready, fire events");
                this.uplinkReady = true;
                this.eventBus.emit("flush");
                this.emit("online");
                this.emit("state", this.getState());
            }
        };
        /**
         * WebSocket client event handlers
         */
        const WsOpen = () => {
            var _a, _b, _c;
            /**
             * We're firing two commands when we're connected
             */
            if (!this.closed && ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN) {
                log("Connection opened :)");
                /**
                 * XRPL Cluster state
                 */
                if (this.endpoint.match(/^wss:\/\/(xrplcluster\.com|xrpl\.link|xrpl\.ws)/)) {
                    try {
                        (_b = this === null || this === void 0 ? void 0 : this.connection) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({ __api: "state", origin: "xrpl-client@js/ts" }));
                    }
                    catch (e) { }
                }
                /**
                 * Mandatory messages on connect
                 */
                this.send({
                    id: "_WsClient_Internal_Subscription",
                    command: "subscribe",
                    streams: ["ledger"],
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(ignore, ignore);
                this.send({
                    id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                    command: "server_info",
                }, { sendIfNotReady: true, noReplayAfterReconnect: true }).then(() => {
                    connectionReady();
                }, ignore);
            }
            else {
                try {
                    log("Close #1");
                    (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.close();
                }
                catch (e) {
                    // If timing: came online after close: kill
                }
            }
        };
        const WsClose = (event) => {
            this.emit("close");
            this.emit("state", this.getState());
            if (this.uplinkReady) {
                // Was online
                this.emit("offline");
                // Was online, so start a new cycle instead of trying the next node
                this.endpoint = this.endpoints[0];
            }
            this.uplinkReady = false;
            this.serverInfo = undefined;
            logWarning("Upstream/Websocket closed", event === null || event === void 0 ? void 0 : event.code, event === null || event === void 0 ? void 0 : event.reason);
            WsCleanup();
            if (!this.closed) {
                this.emit("retry");
                logWarning(`Not closed on purpose, reconnecting after ${reconnectTime()}...`);
                setTimeout(() => {
                    this.eventBus.emit("reconnect");
                }, reconnectTime() * 1000);
            }
            else {
                log("Closed on purpose, not reconnecting");
            }
        };
        const handleServerInfo = (message, returnOnly = false) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
            if ((_a = message === null || message === void 0 ? void 0 : message.result) === null || _a === void 0 ? void 0 : _a.info) {
                const serverState = returnOnly
                    ? Object.assign({}, this.serverState)
                    : this.serverState;
                const serverInfo = message;
                if (!this.serverInfo) {
                    if (!returnOnly) {
                        logNodeInfo("Connected, server_info:", {
                            pubkey_node: serverInfo.result.info.pubkey_node,
                            network_id: ((_b = serverInfo.result.info) === null || _b === void 0 ? void 0 : _b.network_id) || 0,
                            build_version: serverInfo.result.info.build_version,
                            complete_ledgers: serverInfo.result.info.complete_ledgers,
                        });
                    }
                }
                if ((_e = (_d = (_c = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.validated_ledger) === null || _e === void 0 ? void 0 : _e.reserve_base_xrp) {
                    serverState.reserveBase =
                        Number(serverInfo.result.info.validated_ledger.reserve_base_xrp) ||
                            null;
                }
                if ((_h = (_g = (_f = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.validated_ledger) === null || _h === void 0 ? void 0 : _h.reserve_inc_xrp) {
                    serverState.reserveInc =
                        Number(serverInfo.result.info.validated_ledger.reserve_inc_xrp) ||
                            null;
                }
                if ((_k = (_j = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.complete_ledgers) {
                    serverState.validatedLedgers =
                        serverInfo.result.info.complete_ledgers;
                }
                if ((_l = serverInfo === null || serverInfo === void 0 ? void 0 : serverInfo.result) === null || _l === void 0 ? void 0 : _l.info) {
                    serverState.networkId = serverInfo.result.info.network_id || 0;
                }
                const msRoundTrip = Number(new Date()) -
                    Number(String((message === null || message === void 0 ? void 0 : message.id) || "")
                        .split("@")
                        .reverse()[0]);
                if (msRoundTrip) {
                    serverState.latency.push({
                        moment: new Date(),
                        value: msRoundTrip,
                    });
                    serverState.latency.splice(0, serverState.latency.length - 10);
                }
                const fee = Number(((_o = (_m = serverInfo.result.info) === null || _m === void 0 ? void 0 : _m.validated_ledger) === null || _o === void 0 ? void 0 : _o.base_fee_xrp) ||
                    (this.options.feeDropsDefault || feeDropsDefault) / 1000000) *
                    1000000 *
                    feeCushion;
                if (fee && fee <= (this.options.feeDropsMax || feeDropsMax)) {
                    serverState.fee.push({
                        moment: new Date(),
                        value: fee,
                    });
                    serverState.fee.splice(0, serverState.fee.length - 5);
                }
                if (!returnOnly) {
                    this.serverInfo = serverInfo;
                }
                else {
                    return { serverInfo, serverState };
                }
            }
        };
        const handleAsyncWsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            if (((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._Request) !== "_WsClient_Internal_Subscription") {
                let matchingSubscription;
                if ((_b = message === null || message === void 0 ? void 0 : message.id) === null || _b === void 0 ? void 0 : _b._WsClient) {
                    const _matching = this.subscriptions.filter((s) => { var _a; return s.id === ((_a = message === null || message === void 0 ? void 0 : message.id) === null || _a === void 0 ? void 0 : _a._WsClient); });
                    if (_matching.length > 0) {
                        matchingSubscription = _matching[0];
                        matchingSubscription.promiseCallables.resolve(Object.assign(message, {
                            id: (_c = message === null || message === void 0 ? void 0 : message.id) === null || _c === void 0 ? void 0 : _c._Request,
                        }));
                    }
                }
                this.emit("message", message);
                if ((message === null || message === void 0 ? void 0 : message.type) === "ledgerClosed" &&
                    typeof (message === null || message === void 0 ? void 0 : message.validated_ledgers) === "string") {
                    logMessage("Async", message.type);
                    Object.assign(this.serverState, {
                        validatedLedgers: message.validated_ledgers,
                        reserveBase: Number(message === null || message === void 0 ? void 0 : message.reserve_base) / 1000000 || null,
                        reserveInc: Number(message === null || message === void 0 ? void 0 : message.reserve_inc) / 1000000 || null,
                    });
                    this.emit("ledger", message);
                    /**
                     * Always request a server_info for a received ledger as well
                     */
                    this.send({
                        id: "_WsClient_Internal_ServerInfo@" + Number(new Date()),
                        command: "server_info",
                    }).then(ignore, ignore);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "path_find") {
                    logMessage("Async", message.type);
                    this.emit("path", message);
                }
                else if ((message === null || message === void 0 ? void 0 : message.type) === "transaction") {
                    logMessage("Async", message.type);
                    this.emit("transaction", message);
                }
                else if (message === null || message === void 0 ? void 0 : message.validation_public_key) {
                    logMessage("Async", "validation");
                    this.emit("validation", message);
                }
                else {
                    if (((_d = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _d === void 0 ? void 0 : _d.command) === "path_find") {
                        logMessage("Async", (_e = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _e === void 0 ? void 0 : _e.command);
                        this.emit("path", message);
                    }
                    else if (((_f = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _f === void 0 ? void 0 : _f.command) === "subscribe" &&
                        Array.isArray((_g = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _g === void 0 ? void 0 : _g.streams) &&
                        ((_h = matchingSubscription === null || matchingSubscription === void 0 ? void 0 : matchingSubscription.request) === null || _h === void 0 ? void 0 : _h.streams.indexOf("ledger")) > -1) {
                        logMessage("Async", "subscription:ledger");
                        this.emit("ledger", (message === null || message === void 0 ? void 0 : message.result) ? message.result : message);
                    }
                    else if (matchingSubscription) {
                        // Don't log `Unknown` as we know this
                    }
                    else {
                        const isInternal = ((_j = message === null || message === void 0 ? void 0 : message.id) === null || _j === void 0 ? void 0 : _j._Request) &&
                            String(message.id._Request).match(/^_WsClient_Internal/);
                        if (!isInternal) {
                            try {
                                const clusterInfo = message;
                                if ((clusterInfo === null || clusterInfo === void 0 ? void 0 : clusterInfo.type) === "PROXY") {
                                    this.clusterInfo_ = clusterInfo;
                                    this.emit("clusterinfo", this.clusterInfo_);
                                    return;
                                }
                            }
                            catch (e) { }
                            logMessage(`Handle <UNKNOWN> Async Message`, {
                                internalId: (_k = message === null || message === void 0 ? void 0 : message.id) === null || _k === void 0 ? void 0 : _k._WsClient,
                                matchingSubscription,
                                type: message === null || message === void 0 ? void 0 : message.type,
                                message,
                            });
                        }
                    }
                }
            }
        };
        const WsMessage = (message) => {
            var _a, _b, _c, _d, _e, _f;
            try {
                (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                const messageJson = JSON.parse(message.data);
                this.lastContact = new Date();
                if ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient) {
                    // Got response on a command, process accordingly
                    const matchingSubscription = this.subscriptions.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    const matchingCall = this.pendingCalls.filter((call) => {
                        var _a;
                        return call.id === ((_a = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _a === void 0 ? void 0 : _a._WsClient);
                    });
                    if (matchingSubscription.length === 1) {
                        handleAsyncWsMessage(messageJson);
                    }
                    else if (matchingCall.length === 1) {
                        const internalServerInfoCall = String(((_d = (_c = (_b = matchingCall[0]) === null || _b === void 0 ? void 0 : _b.request) === null || _c === void 0 ? void 0 : _c.id) === null || _d === void 0 ? void 0 : _d._Request) || "").split("@")[0] === "_WsClient_Internal_ServerInfo";
                        Object.assign(messageJson, {
                            id: (_e = messageJson === null || messageJson === void 0 ? void 0 : messageJson.id) === null || _e === void 0 ? void 0 : _e._Request,
                        });
                        if (((_f = matchingCall[0].sendOptions) === null || _f === void 0 ? void 0 : _f.timeoutSeconds) &&
                            matchingCall[0].timeout) {
                            clearTimeout(matchingCall[0].timeout);
                        }
                        matchingCall[0].promiseCallables.resolve((messageJson === null || messageJson === void 0 ? void 0 : messageJson.result) || messageJson);
                        this.pendingCalls.splice(this.pendingCalls.indexOf(matchingCall[0]), 1);
                        if (!internalServerInfoCall) {
                            log("Â» Pending Call Length", this.pendingCalls.length);
                        }
                        else {
                            handleServerInfo(messageJson);
                        }
                    }
                    else {
                        // Subscription/path finding ack
                        handleAsyncWsMessage(messageJson);
                    }
                }
                else {
                    // Subscription/path finding followup
                    handleAsyncWsMessage(messageJson);
                }
            }
            catch (e) {
                logWarning("Uplink response: parse error", e.message);
            }
        };
        const WsError = (error) => {
            logWarning("Upstream/Websocket error");
        };
        const applyCallTimeout = (call) => {
            var _a;
            if (((_a = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _a === void 0 ? void 0 : _a.timeoutSeconds) && !(call === null || call === void 0 ? void 0 : call.timeout)) {
                Object.assign(call, {
                    timeout: setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                        var _b;
                        const didTimeout = (yield Promise.race([
                            call.promise,
                            Promise.resolve("_WsClient_Internal_CallResolved"),
                        ])) === "_WsClient_Internal_CallResolved";
                        if (didTimeout) {
                            call.promiseCallables.reject(new Error(`Call timeout after ${(_b = call.sendOptions) === null || _b === void 0 ? void 0 : _b.timeoutSeconds} seconds`));
                        }
                    }), Number(call.sendOptions.timeoutSeconds) * 1000),
                });
            }
        };
        const process = (call) => {
            var _a, _b, _c, _d;
            // const isSubscription = call.request.command === "subscribe";
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log("  > Process call", call.id, call.request.command);
            }
            try {
                // log(call.request);
                (_c = this === null || this === void 0 ? void 0 : this.connection) === null || _c === void 0 ? void 0 : _c.send(JSON.stringify(call.request));
                if ((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline) {
                    // logWarning("APPLY TIMEOUT ONLY AFTER GOING ONLINE");
                    applyCallTimeout(call);
                }
            }
            catch (e) {
                logWarning("Process (send to uplink) error", e.message);
            }
        };
        const call = (call) => {
            var _a, _b, _c, _d, _e;
            if (String(((_b = (_a = call === null || call === void 0 ? void 0 : call.request) === null || _a === void 0 ? void 0 : _a.id) === null || _b === void 0 ? void 0 : _b._Request) || "").split("@")[0] !==
                "_WsClient_Internal_ServerInfo") {
                log(`Call ${call.id}: ${call.request.command}\n   > `, this.uplinkReady
                    ? "Uplink ready, pass immediately"
                    : ((_c = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _c === void 0 ? void 0 : _c.sendIfNotReady)
                        ? "Uplink not flagged as ready yet, but `sendIfNotReady` = true, so go ahead"
                        : "Uplink not ready, wait for flush");
            }
            if (!((_d = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _d === void 0 ? void 0 : _d.timeoutStartsWhenOnline)) {
                // logWarning("APPLY TIMEOUT NO MATTER ONLINE/OFFLINE STATE");
                applyCallTimeout(call);
            }
            if (this.uplinkReady || ((_e = call === null || call === void 0 ? void 0 : call.sendOptions) === null || _e === void 0 ? void 0 : _e.sendIfNotReady)) {
                process(call);
            }
        };
        const flush = () => {
            /**
             * Flush all pending calls & subscriptions
             * to new uplink.
             */
            log("Connected, flushing pending calls & subscriptions");
            this.pendingCalls.forEach((call) => {
                process(call);
            });
            this.subscriptions.forEach((call) => {
                process(call);
            });
        };
        const reinstate = (options) => {
            (0, assert_1.default)(!this.destroyed, "Object is in destroyed state");
            log("Reinstating..., options:", options || {});
            if (options === null || options === void 0 ? void 0 : options.forceNextUplink) {
                this.uplinkReady = false; // Prevents going back to endpoint[0]
                clearTimeout(livelinessCheck);
                selectNextUplink();
            }
            else {
                this.closed = false;
                alive();
            }
            connect();
        };
        const close = (error) => {
            var _a;
            log("Closing connection");
            this.emit("close");
            this.closed = true;
            try {
                log("Close #2");
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            clearTimeout(livelinessCheck);
            if (error) {
                this.emit("error", error);
            }
        };
        const destroy = (error) => {
            this.destroyed = true;
            close(error);
            WsCleanup();
            this.subscriptions.forEach((subscription) => {
                subscription.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.pendingCalls.forEach((call) => {
                call.promiseCallables.reject(new Error("Class (connection) hard close requested"));
            });
            this.eventBus.off("__WsClient_call", call);
            this.eventBus.off("__WsClient_destroy", destroy);
            this.eventBus.off("__WsClient_close", close);
            this.eventBus.off("__WsClient_reinstate", reinstate);
            this.eventBus.off("flush", flush);
            this.eventBus.off("reconnect", connect);
        };
        const WsCleanup = () => {
            log("Cleanup");
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("open", WsOpen);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("message", WsMessage);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("error", WsError);
            (this === null || this === void 0 ? void 0 : this.connection).removeEventListener("close", WsClose);
        };
        const selectNextUplink = () => {
            const nextEndpointIndex = this.endpoints.indexOf(this.endpoint) + 1;
            logWarning("--- Current endpoint", this.endpoint);
            this.endpoint =
                this.endpoints[nextEndpointIndex >= this.endpoints.length ? 0 : nextEndpointIndex];
            logWarning("--- New endpoint", this.endpoint);
            this.serverState.connectAttempts = 0;
            this.emit("nodeswitch", this.endpoint);
            if (nextEndpointIndex >= this.endpoints.length) {
                this.emit("round");
            }
        };
        const connect = () => {
            var _a, _b, _c, _d;
            try {
                log("Close #3");
                WsCleanup();
                (_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.close();
            }
            catch (e) {
                //
            }
            log("connect()", this.endpoint);
            this.serverState.connectAttempts++;
            if (this.options.maxConnectionAttempts &&
                Number(((_b = this.options) === null || _b === void 0 ? void 0 : _b.maxConnectionAttempts) || 1) > 1 &&
                this.serverState.connectAttempts >=
                    Number(((_c = this.options) === null || _c === void 0 ? void 0 : _c.maxConnectionAttempts) || 1)) {
                logNodeInfo("Too many connection attempts", this.serverState.connectAttempts, (_d = this.options) === null || _d === void 0 ? void 0 : _d.maxConnectionAttempts);
                log(this.endpoint, this.endpoints, this.endpoints.length, this.endpoints.indexOf(this.endpoint));
                if (this.endpoints.length > 1 &&
                    this.endpoints.indexOf(this.endpoint) > -1) {
                    logWarning("Multiple endpoints, max. connection attempts exceeded. Switch endpoint.");
                    selectNextUplink();
                }
                else {
                    logWarning("Only one valid endpoint, after the max. connection attempts: game over");
                    close(new Error("Max. connection attempts exceeded"));
                }
            }
            if (!this.closed) {
                if (this.options.tryAllNodes) {
                    logWarning("!!!".repeat(30) +
                        "\n!!!\n!!!    Trying all nodes. WARNING! IF YOU DO NOT EXPLICITLY NEED THIS,\n!!!    DO NOT USE THE `tryAllNodes` OPTION (to prevent wasting resources)\n!!!\n" +
                        "!!!".repeat(30) +
                        "\n");
                }
                const allEndpoints = (this.options.tryAllNodes ? this.endpoints : [this.endpoint]).map((endpoint) => {
                    var _a, _b;
                    log("Connecting", endpoint);
                    /**
                     * Alternative WebSocket implementation here for Bun:
                     * Postprocessed in npm build cli
                     */
                    let WssClient = typeof WebSocket !== 'undefined' ? WebSocket : websocket_1.w3cwebsocket
                    if (typeof require !== 'undefined') {
                      try {
                        WssClient = require('ws').default
                      } catch (e) {}
                    }
                    const connection = new (typeof WssClient !== typeof _NA_ ? WssClient : websocket_1.w3cwebsocket)(endpoint, // url
                    undefined, // protocols
                    undefined, // origin
                    Object.assign(((_a = this.options) === null || _a === void 0 ? void 0 : _a.httpHeaders) || {}, {
                        "user-agent": "xrpl-client@js/ts",
                    }), // headers
                    ((_b = this.options) === null || _b === void 0 ? void 0 : _b.httpRequestOptions) || {}, // requestOptions
                    {
                        maxReceivedFrameSize: 0x80000000,
                        maxReceivedMessageSize: 0x200000000, // 8GB
                    } // IClientConfig
                    );
                    // Prevent possible DNS resolve hang, and a custom
                    // resolver sucks
                    setTimeout(() => {
                        var _a;
                        if (connection.readyState !== websocket_1.w3cwebsocket.OPEN &&
                            ((_a = this.connection) === null || _a === void 0 ? void 0 : _a.readyState) !== websocket_1.w3cwebsocket.OPEN) {
                            log("Close #4 -- FORCED, inner connection timeout");
                            connection.close();
                            if (this.options.tryAllNodes) {
                                /**
                                 * Just do this once per X interval, instead of per connection.
                                 * We don't want all simultaneous connections to fire this and
                                 * kick off a fork (connection) bomb, so assuming they all
                                 * got tried if we're here, only fire reconnet for the very first
                                 * endpoint (as it'll make them all reconnect).
                                 */
                                if (this.endpoints.indexOf(endpoint) === 0) {
                                    this.eventBus.emit("reconnect");
                                }
                            }
                            else {
                                this.eventBus.emit("reconnect");
                            }
                        }
                    }, reconnectTime() * 1000 - 1);
                    const raceOpenHandler = () => {
                        log("OPEN", endpoint);
                        connection.send(JSON.stringify({ command: "server_info" }));
                    };
                    const raceMessageHandler = (message) => {
                        var _a;
                        (0, assert_1.default)(typeof message.data === "string", "Unexpected incoming WebSocket message data type");
                        const messageJson = JSON.parse(message.data);
                        const handledServerInfo = handleServerInfo(messageJson, true);
                        if (handledServerInfo) {
                            const serverState = this.getState(handledServerInfo.serverState);
                            if (typeof serverState.ledger.last === "number" &&
                                (Number(serverState.ledger.count || 0) || 0) > 0) {
                                // This one is first & sane
                                logNodeInfo("Race won by endpoint:", {
                                    endpoint,
                                    build_version: handledServerInfo.serverInfo.result.info.build_version,
                                    complete_ledgers: handledServerInfo.serverInfo.result.info.complete_ledgers,
                                    pubkey_node: handledServerInfo.serverInfo.result.info.pubkey_node,
                                    network_id: ((_a = handledServerInfo.serverInfo.result.info) === null || _a === void 0 ? void 0 : _a.network_id) || 0,
                                });
                                // this.options.tryAllNodes = false;
                                this.connection = connection;
                                this.endpoint = endpoint;
                                WsOpen();
                                WsMessage(message);
                                allEndpoints.forEach((iConnection) => {
                                    iConnection.removeEventListener("open", raceOpenHandler);
                                    iConnection.removeEventListener("message", raceMessageHandler);
                                    if (iConnection != connection) {
                                        log("Close #5");
                                        iConnection.close();
                                        logNodeInfo("Cleanup: closing connection & clearing event listeners for lost race connection", iConnection.url);
                                    }
                                    else {
                                        logNodeInfo("Cleanup: cleared event listeners for winning node", iConnection.url);
                                    }
                                });
                                connection.addEventListener("open", WsOpen);
                                connection.addEventListener("message", WsMessage);
                                connection.addEventListener("error", WsError);
                                connection.addEventListener("close", WsClose);
                            }
                        }
                    };
                    connection.addEventListener("open", raceOpenHandler);
                    connection.addEventListener("message", raceMessageHandler);
                    return connection;
                });
            }
            return this === null || this === void 0 ? void 0 : this.connection;
        };
        this.eventBus.on("__WsClient_call", call);
        this.eventBus.on("__WsClient_destroy", destroy);
        this.eventBus.on("__WsClient_close", close);
        this.eventBus.on("__WsClient_reinstate", reinstate);
        this.eventBus.on("flush", flush);
        this.eventBus.on("reconnect", connect);
        connect();
    }
    ready() {
        return new Promise((resolve, reject) => {
            const state = this.getState();
            if (state.online &&
                state.secLastContact &&
                state.secLastContact < 10 &&
                state.ledger.last) {
                // We're good
                return resolve(this);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("ledger", () => {
                    resolve(this);
                });
            }
        });
    }
    definitions() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // null if not checked before
            if (this.networkDefinitions === null) {
                yield this.ready();
                const definitions = yield this.send({ command: "server_definitions" });
                if (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.FIELDS) === "object") {
                    this.networkDefinitions = definitions;
                    return this.networkDefinitions;
                }
                // Error, no definitions command, fallback to defaults
                if ((typeof (definitions === null || definitions === void 0 ? void 0 : definitions.status) === "string" &&
                    definitions.status.match(/error/i)) ||
                    (typeof (definitions === null || definitions === void 0 ? void 0 : definitions.error) === "string" &&
                        definitions.error.match(/unknown/i))) {
                    this.networkDefinitions = {};
                }
            }
            // return null if {} (empty object) to fall back to defaults;
            // null internally (property) means unfetched, null externally
            // means fall back to defaults.
            return typeof ((_a = this.networkDefinitions) === null || _a === void 0 ? void 0 : _a.FIELDS) === "object"
                ? this.networkDefinitions
                : null;
        });
    }
    send(call, sendOptions = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const _call = Object.assign({}, call);
            (0, assert_1.default)(typeof _call === "object" && _call, "`send()`: expecting object containing `command`");
            (0, assert_1.default)(typeof _call.command === "string", "`command` must be typeof string");
            this.callId++;
            const promiseCallables = {
                resolve: (arg) => { },
                reject: (arg) => { },
            };
            const promise = new Promise((resolve, reject) => {
                Object.assign(promiseCallables, {
                    resolve: (arg) => {
                        Object.defineProperty(arg, 'id', {
                            enumerable: false,
                            writable: false,
                            value: call === null || call === void 0 ? void 0 : call.id,
                        });
                        return resolve(arg);
                    },
                    reject,
                });
            });
            const pendingCall = {
                id: this.callId,
                request: Object.assign(_call, {
                    id: {
                        _WsClient: this.callId,
                        _Request: _call === null || _call === void 0 ? void 0 : _call.id,
                    },
                    command: _call.command.toLowerCase().trim(),
                }),
                promise,
                promiseCallables,
                sendOptions,
            };
            if (this.destroyed) {
                promiseCallables.reject(new Error("Client in destroyed state"));
                return promise;
            }
            const isSubscription = (pendingCall.request.command === "subscribe" ||
                pendingCall.request.command === "unsubscribe" ||
                pendingCall.request.command === "path_find") &&
                !(sendOptions === null || sendOptions === void 0 ? void 0 : sendOptions.noReplayAfterReconnect);
            if (((_a = pendingCall.request) === null || _a === void 0 ? void 0 : _a.command) === "unsubscribe" &&
                Array.isArray((_b = pendingCall.request) === null || _b === void 0 ? void 0 : _b.streams) &&
                ((_c = pendingCall.request) === null || _c === void 0 ? void 0 : _c.streams.indexOf("ledger")) > -1) {
                pendingCall.request.streams.splice(pendingCall.request.streams.indexOf("ledger"), 1);
                if (pendingCall.request.streams.length === 0 &&
                    Object.keys(pendingCall.request).filter((key) => key !== "id" && key !== "streams" && key !== "command").length === 0) {
                    // Unsubscribing (just) streams
                    return Promise.reject(new Error("Unsubscribing from (just) the ledger stream is not allowed"));
                }
            }
            if (String((_call === null || _call === void 0 ? void 0 : _call.id) || "").split("@")[0] !== "_WsClient_Internal_ServerInfo") {
                this[isSubscription ? "subscriptions" : "pendingCalls"].push(pendingCall);
            }
            this.eventBus.emit("__WsClient_call", pendingCall);
            return promise;
        });
    }
    getState(forcedServerState) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        const serverState = forcedServerState
            ? forcedServerState
            : this.serverState;
        const ledgerCount = serverState.validatedLedgers
            .split(",")
            .map((m) => {
            const Range = m.split("-");
            return Range.length > 1 ? parseInt(Range[1]) - parseInt(Range[0]) : 1;
        })
            .reduce((a, b) => a + b, 0);
        return {
            online: this.uplinkReady &&
                !this.closed &&
                ((_a = this === null || this === void 0 ? void 0 : this.connection) === null || _a === void 0 ? void 0 : _a.readyState) === websocket_1.w3cwebsocket.OPEN,
            latencyMs: {
                last: serverState.latency
                    .slice(-1)
                    .map((latencyRecord) => latencyRecord.value)[0] || null,
                avg: serverState.latency
                    .map((latencyRecord) => latencyRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.latency.length || null,
                secAgo: Number(new Date()) / 1000 -
                    serverState.latency
                        .slice(-1)
                        .map((latencyRecord) => Number(latencyRecord.moment) / 1000)[0] ||
                    null,
            },
            server: {
                version: ((_d = (_c = (_b = this.serverInfo) === null || _b === void 0 ? void 0 : _b.result) === null || _c === void 0 ? void 0 : _c.info) === null || _d === void 0 ? void 0 : _d.build_version) || "",
                uptime: ((_g = (_f = (_e = this.serverInfo) === null || _e === void 0 ? void 0 : _e.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.uptime) || 0,
                publicKey: ((_k = (_j = (_h = this.serverInfo) === null || _h === void 0 ? void 0 : _h.result) === null || _j === void 0 ? void 0 : _j.info) === null || _k === void 0 ? void 0 : _k.pubkey_node) || "",
                networkId: ((_o = (_m = (_l = this.serverInfo) === null || _l === void 0 ? void 0 : _l.result) === null || _m === void 0 ? void 0 : _m.info) === null || _o === void 0 ? void 0 : _o.network_id) || 0,
                uri: this.endpoint,
            },
            ledger: {
                last: Number(serverState.validatedLedgers
                    .split(",")
                    .reverse()[0]
                    .split("-")
                    .reverse()[0]),
                validated: serverState.validatedLedgers,
                count: serverState.validatedLedgers === "" ? 0 : ledgerCount,
            },
            fee: {
                last: serverState.fee.slice(-1).map((feeRecord) => feeRecord.value)[0] ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                avg: serverState.fee
                    .map((feeRecord) => feeRecord.value)
                    .reduce((a, b) => a + b, 0) / serverState.fee.length ||
                    this.options.feeDropsDefault ||
                    feeDropsDefault,
                secAgo: Number(new Date()) / 1000 -
                    serverState.fee
                        .slice(-1)
                        .map((feeRecord) => Number(feeRecord.moment) / 1000)[0] || null,
            },
            reserve: {
                base: serverState.reserveBase,
                owner: serverState.reserveInc,
            },
            secLastContact: this.lastContact
                ? Number(new Date()) / 1000 - Number(this.lastContact) / 1000
                : null,
        };
    }
    close() {
        // assert(!this.closed, "Object already in closed state");
        log(`> CLOSE`);
        this.eventBus.emit("__WsClient_close");
    }
    reinstate(options) {
        // assert(!this.closed, "Object already reinstated state");
        log(`> REINSTATE`);
        this.eventBus.emit("__WsClient_reinstate", options);
    }
    destroy() {
        // assert(!this.closed, "Object already in destroyed state");
        log(`> DESTROY`);
        this.eventBus.emit("__WsClient_destroy");
    }
    clusterInfo() {
        return new Promise((resolve, reject) => {
            if (this.clusterInfo_) {
                // We're good
                return resolve(this.clusterInfo_);
            }
            else {
                // Let's wait to make sure we're really connected
                this.on("clusterinfo", (info) => {
                    resolve(info);
                });
            }
        });
    }
}
exports.XrplClient = XrplClient;
