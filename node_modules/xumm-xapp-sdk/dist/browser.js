(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.xAppSdk = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.xAppEvents = void 0;
var xAppEvents;
(function (xAppEvents) {
    xAppEvents["scanQr"] = "scanQr";
    xAppEvents["payloadResolved"] = "payloadResolved";
    xAppEvents["selectDestination"] = "selectDestination";
})(xAppEvents = exports.xAppEvents || (exports.xAppEvents = {}));
// export interface xAppActionScanQr {
//   // command: scanQr
// }

},{}],2:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],"xApp":[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.xApp = void 0;
const events_1 = require("events");
const types_1 = require("./types");
__exportStar(require("./types"), exports);
// localStorage.debug = "xapp*";
const docMinAliveSec = 0.25;
const attemptMs = 250;
const attemptDuration = 2000;
const appStart = Number(new Date());
let documentIsReady;
const documentReadyPromise = new Promise((resolve) => {
    documentIsReady = (value) => {
        console.log("Doc Ready...");
        const timeSinceDocLoad = (Number(new Date()) - appStart) / 1000;
        if (timeSinceDocLoad < docMinAliveSec /* Seconds */) {
            // Stall
            console.log("Doc not alive >= " +
                docMinAliveSec +
                " sec, stalling for " +
                (docMinAliveSec - timeSinceDocLoad));
            setTimeout(function () {
                resolve(value);
            }, (docMinAliveSec - timeSinceDocLoad) * 1000);
        }
        else {
            // Go ahead
            console.log("Doc alive " + docMinAliveSec + "+ sec, go ahead");
            resolve(value);
        }
    };
});
documentReadyPromise
    .then(() => {
    console.log("documentReadyPromise resolved");
})
    .catch((e) => {
    console.log(e);
});
if (typeof document !== "undefined") {
    document.addEventListener("readystatechange", (event) => {
        console.log("(readystatechange: [ " + document.readyState + " ])");
        if (document.readyState === "complete") {
            documentIsReady();
        }
    });
}
if (typeof window !== "undefined") {
    console.log("Loading xApp SDK");
}
let _window = (typeof window !== "undefined" ? window : {});
let isSandbox = false;
if (_window === null || _window === void 0 ? void 0 : _window.parent) {
    // XAPP PROXY
    (_a = _window.parent) === null || _a === void 0 ? void 0 : _a.postMessage("XAPP_PROXY_INIT", "*");
}
const xAppActionAttempt = (command, options, attempt = 0) => __awaiter(void 0, void 0, void 0, function* () {
    var _b, _c;
    yield documentReadyPromise;
    if (typeof (_window === null || _window === void 0 ? void 0 : _window.ReactNativeWebView) !== "undefined" || isSandbox) {
        const timeSinceDocLoad = (Number(new Date()) - appStart) / 1000;
        if (["close"].indexOf(command) > -1) {
            // Close command awaits app nav state, min sec. alive 4
            const minAliveTimeSec = 4;
            if (timeSinceDocLoad < minAliveTimeSec) {
                console.log("xApp close, doc alive < minAliveTimeSec, stall: " +
                    (minAliveTimeSec - timeSinceDocLoad));
                yield new Promise((resolve) => {
                    setTimeout(() => {
                        resolve(true);
                    }, (minAliveTimeSec - timeSinceDocLoad) * 1000);
                });
            }
        }
        const msgToPost = JSON.stringify(Object.assign({ command }, (options || {})));
        if (isSandbox) {
            (_b = _window.parent) === null || _b === void 0 ? void 0 : _b.postMessage(msgToPost, "*");
        }
        else {
            (_c = _window.ReactNativeWebView) === null || _c === void 0 ? void 0 : _c.postMessage(msgToPost);
        }
        console.log("xAppActionAttempt Success", command, options);
        return true;
    }
    else {
        if (attempt * attemptMs < attemptDuration) {
            // Another attempt
            console.log("xAppActionAttempt Attempt " + attempt + " » Retry", command, options);
            yield new Promise((resolve) => {
                setTimeout(resolve, attemptMs);
            });
            return xAppActionAttempt(command, options, attempt + 1);
        }
        else {
            // Nope
            console.log("xAppActionAttempt Failed after attempt " + attempt, command, options);
            return new Error("xApp." +
                command.replace(/^xApp/, "") +
                ": could not contact Xumm App Host");
        }
    }
});
class xAppThread extends events_1.EventEmitter {
    constructor() {
        super();
        if (document.readyState === "complete") {
            documentIsReady();
        }
        const eventHandler = (event) => {
            const rEvent = event;
            if (typeof (rEvent === null || rEvent === void 0 ? void 0 : rEvent.data) === "string" &&
                rEvent.data === "XAPP_PROXY_INIT_ACK") {
                console.log("xApp Proxy ACK received, switching to PROXY (SANDBOX) mode");
                isSandbox = true;
                return;
            }
            try {
                const _event = JSON.parse((rEvent === null || rEvent === void 0 ? void 0 : rEvent.data) || "{}");
                console.log({ _event });
                if (typeof _event === "object" && _event !== null) {
                    if (typeof _event.method === "string" &&
                        _event.method in types_1.xAppEvents) {
                        console.log("xApp Event received", _event.method, _event);
                        const method = _event.method;
                        delete _event.method;
                        switch (method) {
                            case String(types_1.xAppEvents.payloadResolved):
                                this.emit("payload", _event);
                                break;
                            case String(types_1.xAppEvents.scanQr):
                                this.emit("qr", _event);
                                break;
                            case String(types_1.xAppEvents.selectDestination):
                                this.emit("destination", _event);
                                break;
                        }
                    }
                    else {
                        console.log("xApp Event received, not in xAppEvents", _event.method, types_1.xAppEvents);
                    }
                }
            }
            catch (e) {
                const emessage = (e === null || e === void 0 ? void 0 : e.message) || "";
                if (!emessage.match(/XAPP_PROXY_INIT/)) {
                    console.log("xApp Event received, cannot parse as JSON", emessage);
                }
            }
        };
        if (typeof window.addEventListener === "function") {
            window.addEventListener("message", eventHandler);
        }
        if (typeof document.addEventListener === "function") {
            document.addEventListener("message", eventHandler);
        }
    }
    getEnvironment() {
        const t = thread();
        if (!t) {
            return { version: "", ott: "" };
        }
        return t.getEnvironment();
    }
    navigate(navigateOptions) {
        if (typeof (navigateOptions === null || navigateOptions === void 0 ? void 0 : navigateOptions.xApp) !== "string") {
            return Promise.reject(new Error("xApp.navigate: Invalid argument: `xApp`"));
        }
        return xAppActionAttempt("xAppNavigate", navigateOptions);
    }
    openSignRequest(openSignRequestOptions) {
        if (typeof (openSignRequestOptions === null || openSignRequestOptions === void 0 ? void 0 : openSignRequestOptions.uuid) !== "string") {
            return Promise.reject(new Error("xApp.openSignRequest: Invalid argument: `uuid`"));
        }
        if (!openSignRequestOptions.uuid.match(/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i)) {
            return Promise.reject(new Error("xApp.openSignRequest: Invalid payload UUID"));
        }
        return xAppActionAttempt("openSignRequest", openSignRequestOptions);
    }
    selectDestination(selectDestinationOptions) {
        return xAppActionAttempt("selectDestination", selectDestinationOptions);
    }
    openBrowser(openBrowserOptions) {
        if (typeof (openBrowserOptions === null || openBrowserOptions === void 0 ? void 0 : openBrowserOptions.url) !== "string") {
            return Promise.reject(new Error("xApp.openBrowser: Invalid argument: `url`"));
        }
        return xAppActionAttempt("openBrowser", openBrowserOptions);
    }
    share(shareOptions) {
        if (typeof (shareOptions === null || shareOptions === void 0 ? void 0 : shareOptions.text) !== "string") {
            return Promise.reject(new Error("xApp.share: Invalid argument: `text`"));
        }
        return xAppActionAttempt("share", shareOptions);
    }
    scanQr() {
        return xAppActionAttempt("scanQr");
    }
    tx(txOptions) {
        if (typeof (txOptions === null || txOptions === void 0 ? void 0 : txOptions.tx) !== "string") {
            return Promise.reject(new Error("xApp.tx: Invalid argument: `tx`"));
        }
        if (typeof (txOptions === null || txOptions === void 0 ? void 0 : txOptions.account) !== "string") {
            return Promise.reject(new Error("xApp.tx: Invalid argument: `account`"));
        }
        return xAppActionAttempt("txDetails", txOptions);
    }
    close(closeOptions) {
        return xAppActionAttempt("close", closeOptions);
    }
    ready() {
        return xAppActionAttempt("ready");
    }
    customCommand(customCommand, customCommandOptions) {
        return xAppActionAttempt(customCommand, customCommandOptions);
    }
}
const thread = (_xApp) => {
    let attached = false;
    if (_xApp) {
        if (typeof _window === "object") {
            if (typeof _window._xAppSdk === "undefined") {
                _window._xAppSdk = _xApp;
                attached = true;
            }
        }
    }
    const instance = _window === null || _window === void 0 ? void 0 : _window._xAppSdk;
    if (instance && attached) {
        console.log("xAppSdk attached to window");
    }
    return instance;
};
class xApp {
    constructor() {
        this.xummEnvironment = {
            version: "",
            ott: "",
        };
        if (typeof window === "undefined" || typeof document === "undefined") {
            return;
        }
        if (typeof navigator !== "undefined") {
            if (typeof (navigator === null || navigator === void 0 ? void 0 : navigator.userAgent) === "string") {
                const uaMatch = navigator.userAgent
                    .trim()
                    .match(/xumm\/xapp:([0-9]{1,}\.[0-9]{1,}\.[0-9]{1,}).*ott:([0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12})/);
                if (uaMatch) {
                    this.xummEnvironment.version = uaMatch[1];
                    this.xummEnvironment.ott = uaMatch[2];
                }
            }
        }
        if (this.xummEnvironment.version === "") {
            console.log("Warning: Xumm Version could not be retrieved from User Agent, possibly not loaded in xApp context?");
        }
        if (!thread()) {
            thread(new xAppThread());
        }
    }
    getEnvironment() {
        return this.xummEnvironment;
    }
    on(event, listener) {
        const t = thread();
        if (!t) {
            return;
        }
        t.on(event, listener);
        return this;
    }
    off(event, listener) {
        const t = thread();
        if (!t) {
            return;
        }
        t.off(event, listener);
        return this;
    }
    navigate(navigateOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.navigate(navigateOptions);
    }
    openSignRequest(openSignRequestOptions) {
        const t = thread();
        if (t) {
            if (openSignRequestOptions === null || openSignRequestOptions === void 0 ? void 0 : openSignRequestOptions.uuid) {
                return t.openSignRequest(openSignRequestOptions);
            }
        }
        return;
    }
    selectDestination(selectDestinationOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.selectDestination(selectDestinationOptions);
    }
    openBrowser(openBrowserOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.openBrowser(openBrowserOptions);
    }
    share(shareOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.share(shareOptions);
    }
    scanQr() {
        const t = thread();
        if (!t) {
            return;
        }
        return t.scanQr();
    }
    tx(txOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.tx(txOptions);
    }
    close(closeOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.close(closeOptions);
    }
    ready() {
        const t = thread();
        if (!t) {
            return;
        }
        return t.ready();
    }
    customCommand(customCommand, customCommandOptions) {
        const t = thread();
        if (!t) {
            return;
        }
        return t.customCommand(customCommand, customCommandOptions);
    }
}
exports.xApp = xApp; module.exports = xApp;

},{"./types":1,"events":2}]},{},[])("xApp")
});
;new xAppSdk();
